x <- 1:4; y <- 6:9
x + y
x > 2
y == 8
x * y
x / y
?read.table
for( i in 1:4) {
print(x[i])
}
print(letter)
for(i in 1:4) print(x[i]}
for(i in 1:4) { print(x[i]}
for(i in 1:4) { print(x[i])}
z <- 5
while(z >= 3 && <= 10) {
print(z)
q()
y <- 10
f <- function(x) {
y <- 2
Y ^2 + g(x)
}
g <- function(x) {
x*y
}
f(3)
f <- function(x) {
y <- 2
y^2 + g(x)
}
f(3)
q()
x <- as.Date("1970-01-01")
x
unclass(X)
unclass(X)
unclass(x)
x <- Sys.time()
x
unclass(x)
q()
load("C:/Users/FabioDesk/Dropbox/Academia/NEPAM-FAPESP-2013_17173-5/ARTIGOS/CLIMATE_IMPACTS_HEALTH/R/f99_ln_ts.RData")
x
y
resmodelo <- lm(x~y)
summary(resmodelo)
?fisher.test
fisher.test(x)
library(lmtest)
dwtest
?dwtest
install.package(lmtest)
library(lmtest)
dwtest(x~y)
resmodelo
?lm
lm$coefficients
lm$coefficients
coef(resmodelo)
confint(resmodelo)
?confint
?glm
library(RMySQL)
ucscDb <- dbConnect(MySQL().user="genome", host="genome-mysql.cse.ucsc.edu")
ucscDb <- dbConnect(MySQL(),user="genome", host="genome-mysql.cse.ucsc.edu")
result <- dbGetQuery(ucsDb,"show databases;") dbDisconect(ucscDB)
result <- dbGetQuery(ucsDb,"show databases;") dbDisconnect(ucscDB)
result <- dbGetQuery(ucsDb,"show databases;") dbDisconnect(ucscDb)
result <- dbGetQuery(ucscDb,"show databases;") dbDisconnect(ucscDb)
?dbGetQuery
library(RMySQL)
ucscDb <- dbConnect(MySQL(),user="genome", host="genome-mysql.cse.ucsc.edu")
result <- dbGetQuery(ucscDb,"show databases;") dbDisconnect(ucscDb)
result <- dbGetQuery(ucscDb,"show databases;"); dbDisconnect(ucscDb);
result
library(RMySQL)
ucscDb <- dbConnect(MySQL(),user="genome", host="genome-mysql.cse.ucsc.edu")
result <- dbGetQuery(ucscDb,"show databases;"); dbDisconnect(ucscDb);
result
hg19 <- dbConnect(MySQL(),user="genome", db="hg19" host="genome-mysql.cse.ucsc.edu")
hg19 <- dbConnect(MySQL(),user="genome", db="hg19", host="genome-mysql.cse.ucsc.edu")
allTables <- dbListTables(hg19)
ucscDb <- dbConnect(MySQL(),user="genome", host="genome-mysql.cse.ucsc.edu")
hg19 <- dbConnect(MySQL(),user="genome", db="hg19", host="genome-mysql.cse.ucsc.edu")
allTables <- dbListTables(hg19)
length(allTables)
allTables(1:5)
allTables[1:5]
dbListFields(hg19,"affyU133Plus2")
dbGetQuery(hg19, "select count(*) from affyU133Plus2")
affyData <- dbReadTable(hg19,"affyU133Plus2")
head(affyData)
query <- dbSendQuery(hg19, "select * from affyU133Plus2 where misMatches between 1 and 3")
warings()
warnings()
affyMis <- fetch(query); quantile(affy$misMatches)
affyMis <- fetch(query); quantile(affyMis$misMatches)
affyMisSmall <- fetch(query,n=10); dbClearResult(query);
dim(affyMissSmall)
dim(affyMisSmall)
dbDisconnect(hg19);
con = url("http://scholar.google.com/citations?user=HI-I6C0AAAAJ&hl=en")
htmlCode = redLines(con)
htmlCode = readLines(con)
url <- "http://scholar.google.com/citations?user=HI-I6C0AAAAH&hl=en"
con = url
htmlCode = readLines(con)
htmlCode
htmlCode = readLines(con)
htmlCode[1:8] = readLines(con)
htmlCode[1:5] = readLines(con)
htmlCode[1:2] = readLines(con)
url <- "http://scholar.google.com/citations?user=HI-I6C0AAAAJ&hl=en"
con = url
htmlCode[1:2] = readLines(con)
url <- "https://www.coursera.org/"
con = url
htmlCode[1:2] = readLines(con)
url <- "http://scholar.google.com/citations?user=HI-I6C0AAAAJ&hl=en"
con = url
htmlCode[1:2] = readLines(con)
htmlCode = readLines(con)
htmlCode
close(con)
library(XML)
install.packages(XML)
install.packages("xml")
install.packages("XML")
library(XML)
url <- "http://scholar.google.com/citations?user=HI-I6C0AAAAJ&hl=en"
html <- htmlTreeParse(url, useInternalNodes=T)
xpathSApply(html, "//title", xmlValue)
xpathSApply(html, "//td[@id='col-citedby']title", xmlValue)
xpathSApply(html, "//td[@id='col-citedby']", xmlValue)
list()
list
xpathSApply(html, "//title", xmlValue)
xpathSApply(html, "//td[@id='col-citedby']", xmlValue)
install.packages("httr")
library(httr)
content2 = content(html2,as="text")
html2 = GET(url)
content2 = content(html2,as="text")
parsedHtml = htmlParse(content2,asText=TRUE)
xpathSApply(parsedHtml, "//title", xmlValue)
pg2 = GET("http://httpbin.org/basic=auth/user/passwd"), authenticate("user","passwd")
pg2 = GET("http://httpbin.org/basic=auth/user/passwd")
pg2
pg2 = GET("http://httpbin.org/basic=auth/user/passwd"), authenticate("user","passwd"))
pg2 = GET("http://httpbin.org/basic=auth/user/passwd", authenticate("user","passwd"))
pg2
pg2 = GET("http://httpbin.org/basic-auth/user/passwd", authenticate("user","passwd"))
pg2
names(pg2)
google = handle("http://google.com")
pg1 = GET(handle=google,path="/")
pg2 = GET(handle=google,path="search")
library("httr")
oauth_endpoints("github")
myapp = oauth_app("github", key="b1cb4c2d9422dcdc67b3",secret="46f2923706005f32791cbaa643d7ee4fe6dc41af")
gtoken <- config(token = github_token)
gtoken <- config(token = token319499f3e49695256186ab1c98f679779cc59a82)
github_token <- oauth2.0_token(oauth_endpoints("github"), myapp)
github_token <- oauth2.0_token(oauth_endpoints("github"), myapp)
gtoken <- config(token = github_token)
req <- GET("https://api.github.com/users/jtleek/repos", gtoken)
stop_for_status(req)
content(req)
json1 = content(req)
json2 = jsonlite::fromJSON(toJSON(json1))
?toJSON
library(JSON)
install.packages("JSON")
library(jsonlite)
json2 = jsonlite::fromJSON(toJSON(json1))
json2[1,1:4]
dim(json2)
json2
library(httr)
library(httpuv)
myapp <- oauth_app("github",key="add_your_registered_key",secret = "add_your_secret")
github_token <- oauth2.0_token(oauth_endpoints("github"), myapp)
myapp = oauth_app("myApplication", key="b1cb4c2d9422dcdc67b3",secret="46f2923706005f32791cbaa643d7ee4fe6dc41af")
# 3. Get OAuth credentials
github_token <- oauth2.0_token(oauth_endpoints("github"), myapp)
gtoken <- config(token = github_token)
req <- GET("https://api.github.com/users/jtleek/repos", gtoken)
stop_for_status(req)
content(req)
json1 = content(req)
json2 = jsonlite::fromJSON(toJSON(json1))
json2[1,1:4]
names(json2)
names(json2$events_url)
names(json2$updated_at)
names(json2$id)
json2[1,1:4]
cat(json2)
head(json2)
x <- makeVector(c(1, 2 ,3))
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
x <- makeVector(c(1, 2 ,3))
x
x
x$get()
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
cachemean(x)
cachemean(x)
x$set
xget()
x$get()
x$set(c(4, 5, 6))
x$get()
cachemean(x)
cachemean(x)
x
matrix(c(1, 2 ,3), c(4,5,6,7))
matrix(c(1, 2 ,3), c(4,5,6))
?matrix
matrix(1:10, 4, 5)
makeCacheMatrix <- function(x = matrix()) {
i <- NULL
set <- function(y) {
x <<- y
i <<- NULL
}
get <- function() x
setinv <- function(solve) i <<- inv
getinv <- function() i
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}
x <- makeCacheMatrix(1:10, 4, 5)
x <- makeCacheMatrix(1:10)
x$get()
debug(makeCacheMatrix)
x <- makeCacheMatrix(1:10)
debug(makeCacheMatrix)
x <- makeCacheMatrix(1:10)
x
size <- 1000 # size of the matrix edge, don't make this too big
mymatrix <- matrix(rnorm(size^2), nrow=size, ncol=size)
mymatrix.inverse <- solve(mymatrix)
mymatrix
mymatrix.inverse
special.matrix   <- makeCacheMatrix(mymatrix)
special.matrix
special.matrix$get
special.matrix$get()
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
i <- x$getinv()
if(!is.null(i)) {
message("getting cached data")
return(i)
}
data <- x$get()
i <- solve(data, ...)
x$setinv(i)
i
}
special.matrix$get()
special.solved.1 <- cacheSolve(special.matrix)
makeCacheMatrix <- function(x = matrix()) {
i <- NULL
set <- function(y) {
x <<- y
i <<- NULL
}
get <- function() x
setinv <- function(solve) i <<- solve
getinv <- function() i
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}
x <- makeCacheMatrix(1:10)
x$get()
x
}
size <- 1000 # size of the matrix edge, don't make this too big
mymatrix <- matrix(rnorm(size^2), nrow=size, ncol=size)
mymatrix.inverse <- solve(mymatrix)
mymatrix
mymatrix.inverse
special.matrix   <- makeCacheMatrix(mymatrix)
special.matrix$get()
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
i <- x$getinv()
if(!is.null(i)) {
message("getting cached data")
return(i)
}
data <- x$get()
i <- solve(data, ...)
x$setinv(i)
i
}
cacheSolve(x)
special.solved.1 <- cacheSolve(special.matrix)
special.solved.2 <- cacheSolve(special.matrix)
identical(mymatrix.inverse, special.solved.1) & identical(mymatrix.inverse, special.solved.2)
makeCacheMatrix <- function(x = matrix()) {
i <- NULL
set <- function(y) {
x <<- y
i <<- NULL
}
get <- function() x
setinv <- function(solve) i <<- solve
getinv <- function() i
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}
## Write a short comment describing this function
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
i <- x$getinv()
if(!is.null(i)) {
message("getting cached data")
return(i)
}
data <- x$get()
i <- solve(data, ...)
x$setinv(i)
i
}
#Testing
size <- 3000 # size of the matrix edge, don't make this too big
mymatrix <- matrix(rnorm(size^2), nrow=size, ncol=size)
mymatrix.inverse <- solve(mymatrix)
special.matrix   <- makeCacheMatrix(mymatrix)
special.solved.1 <- cacheSolve(special.matrix)
special.solved.2 <- cacheSolve(special.matrix)
identical(mymatrix.inverse, special.solved.1) & identical(mymatrix.inverse, special.solved.2)
special.solved.3 <- cacheSolve(special.matrix, rep(4,1000))
identical(special.solved.1, special.solved.3)
iden <- mymatrix %*% special.solved.1
round(iden[1:5,1:5])
## Write a short comment describing this function
makeCacheMatrix <- function(x = matrix()) {
i <- NULL
set <- function(y) {
x <<- y
i <<- NULL
}
get <- function() x
setinv <- function(solve) i <<- solve
getinv <- function() i
list(set = set, get = get,
setinv = setinv,
getinv = getinv)
}
## This function computes the inverse of the special "matrix"
## returned by makeCacheMatrix above. If the inverse has already
## been calculated (and the matrix has not changed), then the
## cachesolve should retrieve the inverse from the cache.
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
i <- x$getinv()
if(!is.null(i)) {
message("getting cached data")
return(i)
}
data <- x$get()
i <- solve(data, ...)
x$setinv(i)
i
}
size <- 1000 # size of the matrix edge, don't make this too big
mymatrix <- matrix(rnorm(size^2), nrow=size, ncol=size)
mymatrix.inverse <- solve(mymatrix)
mymatrix
mymatrix.inverse
special.matrix   <- makeCacheMatrix(mymatrix)
special.matrix$get()
special.solved.1 <- cacheSolve(special.matrix)
special.solved.2 <- cacheSolve(special.matrix)
identical(mymatrix.inverse, special.solved.1) & identical(mymatrix.inverse, special.solved.2)
set.sedd(13435)
set.seed(13435)
X <- data.frame("var1"=sample(1:5),"var2"=sample(6:10),"var3"=sample(11:15))
X <- X[sample(1:5),]; X$var2[c(1,3)] = NA
X
X[,1] #Subsetting a specific colum
X[,"var1"] #Subsetting a specific colum
X[1:2,"var2"] #Subsetting a specific colum and row
X[(X$var1 <= 3 & X$var3 > 11),]
X[(X$var1 <= 3 | X$var3 > 15),]
X[wich(X$var1  > 8),]
X[which(X$var1  > 8),]
X[which(X$var2  > 8),]
sort(X$var1)
sort(X$var1, decreasing=T)
sort(X$var2, na.last=T)
X[order(X$var1),]
X[order(X$var1,X$var3),]
library(plyr)
install.packages("plyr")
library(plyr)
arrange(X,var1)
arrange(X,desc(var1)
arrange(X,desc(var1))
arrange(X,desc(var1))
X$var4 <- rnorm(5)
X
Y <- cbind(X, rnorm(5))
Y
head(dat2)
library(downloader)
install.packages(downloader)
install.packages("downloader")
library(downloader)
download("https://raw.githubusercontent.com/thoughtfulbloke/faoexample/master/appleorange.csv", destfile="appleorange.csv")
download("https://raw.githubusercontent.com/thoughtfulbloke/faoexample/master/stability.csv", destfile="stability.csv")
list.files
list.files()
old.wd <- getwd()
new.wd <- ("E:/Cursos/Coursera/Data_Analisys/Getting&Cleaning/W3")
setwd(new.wd)
new.wd <- ("E:/Cursos/Coursera/Data_Analisys/Getting&Cleaning/W3/data")
download("https://raw.githubusercontent.com/thoughtfulbloke/faoexample/master/appleorange.csv", destfile="appleorange.csv")
download("https://raw.githubusercontent.com/thoughtfulbloke/faoexample/master/stability.csv", destfile="stability.csv")
list.files()
new.wd <- ("E:/Cursos/Coursera/Data_Analisys/Getting&Cleaning/W3/data")
setwd(new.wd)
list.files()
download("https://raw.githubusercontent.com/thoughtfulbloke/faoexample/master/appleorange.csv", destfile="appleorange.csv")
download("https://raw.githubusercontent.com/thoughtfulbloke/faoexample/master/stability.csv", destfile="stability.csv")
list.files()
ao <- read.csv("appleorange.csv")
str(ao)
str(aoraw)
aoraw <- read.csv("appleorange.csv", stringsAsFactors=FALSE, header=FALSE)
str(aoraw)
head(aoraw,10)
tail(aoraw,10)
aodata <- aoraw[3:700,]
names(aodata) <- c("country", "countrynumber", "products", "productnumber", "tonnes", "year")
aodata$countrynumber <- as.integer(aodata$countrynumber)
fslines <- which(aodata$country == "Food supply quantity (tonnes) (tonnes)")
aodata <- aodata[(-1 * fslines),]
aodata$tonnes <- gsub("\xca", "", aodata$tonnes)
aodata$tonnes <- gsub(", tonnes \\(\\)", "", aodata$tonnes)
aodata$tonnes <- as.numeric(aodata$tonnes)
aodata$year <- 2009
str(aodata)
tail(dat1, 20)
old.wd <- getwd()
new.wd <- ("E:/Cursos/Coursera/Data_Analisys/Getting&Cleaning/W3")
setwd(new.wd)
dat1 <- read.csv(destfile1, skip = 5, header = F, nrows = 231, col.names = c("CountryCode", "Ranking", "V3", "Economy", "millions of US dollars", "V6", "V7", "V8", "V9", "V10"))
destfile1 <- "data/FGDP.csv"
destfile2 <- "data/FEDSTATS_Country.csv"
list.files("data")
dat1 <- read.csv(destfile1, skip = 5, header = F, nrows = 231, col.names = c("CountryCode", "Ranking", "V3", "Economy", "millions of US dollars", "V6", "V7", "V8", "V9", "V10"))
dat1 <- dat1[,1:5]
dat1 <- dat1[,-3]
dat2 <- read.csv(destfile2)
str(dat1)
str(dat2)
